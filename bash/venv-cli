#!/usr/bin/env bash
#
# venv-cli - python virtual environment manager
#

set -euo pipefail

##
# constants
##

CLI_VERSION="0.4"
DEFAULT_VENV=".venv"

##
# colors
##

BLD=$(tput bold)
RST=$(tput sgr0)
RED=$(tput setaf 1)
GRN=$(tput setaf 2)
YLW=$(tput setaf 3)
MGN=$(tput setaf 5)
CYN=$(tput setaf 6)

##
# helpers
##

__detect_shell() {
  # try to detect shell from PPID first (more reliable)
  local parent_process
  if command -v ps >/dev/null 2>&1; then
    parent_process=$(ps -p $PPID -o comm= 2>/dev/null || true)
    parent_process=${parent_process##*/}  # strip path
    case "$parent_process" in
      zsh|bash|fish|ksh|sh) echo "$parent_process"; return ;;
    esac
  fi

  # fall back to SHELL env var
  if [[ -n "${SHELL:-}" ]]; then
    basename "$SHELL"
  else
    echo "bash"  # default to bash
  fi
}

__rc_file() {
  local shell
  shell=$(__detect_shell)
  case "$shell" in
    zsh) echo "$HOME/.zshrc" ;;
    ksh) echo "$HOME/.kshrc" ;;
    fish) echo "$HOME/.config/fish/config.fish" ;;
    sh) echo "$HOME/.profile" ;;
    *) echo "$HOME/.bashrc" ;;
  esac
}

__indent() {
  # split input on newlines and indent each line
  first_line=1
  echo -e "$1" | while IFS= read -r line; do
    if (( first_line )); then
      first_line=0
      printf "‚îî‚îÄ %s\n" "$line"
    else
      printf "   %s\n" "$line"
    fi
  done
}

_venv_usage() {
  cat << HEREDOC
${BLD}usage${RST}: venv <command> [args]

${BLD}commands${RST}:
  ${CYN}help (h)${RST}              shows this help
  ${CYN}version (v)${RST}           shows version
  ${CYN}init (i)${RST} [path]       creates new venv
  ${CYN}activate (a)${RST} [path]   activates venv
  ${CYN}deactivate (d)${RST}        deactivates venv
  ${CYN}remove (rm)${RST} [path]    removes venv (-f to force)
  ${CYN}doctor${RST}                performs health check
  ${CYN}shellenv${RST}              echoes shell setup

${BLD}notes${RST}:
  - default [path] is always '${DEFAULT_VENV}'
HEREDOC

# if we were called directly, show first-time setup
if (( $1 )); then
  cat << HEREDOC

${BLD}${MGN}first-time setup${RST}
  1. make sure this script is on your PATH
  2. add to your shell's rc file: ${BLD}eval \$(venv-cli shellenv)${RST}
  3. restart your shell, then use ${BLD}venv${RST} not ${BLD}venv-cli${RST}
HEREDOC
fi
}

##
# core actions
##

_venv_init() {
  local target=${1:-$DEFAULT_VENV}
  # refuse if path exists but is not a directory
  if [[ -e $target && ! -d $target ]]; then
    echo "${RED}path exists and is not a directory${RST}: '$target'" >&2
    exit 1
  fi

  if [[ -d $target ]]; then
    echo "${YLW}venv already exists${RST}: '$target'"
    return 0
  fi

  # ensure python3 is available
  if ! command -v python3 >/dev/null 2>&1; then
    echo "${RED}python3 not found${RST}, please ensure it is installed and on your PATH" >&2
    exit 1
  fi

  echo "${GRN}creating new venv${RST}: '$target'..."
  local create_output create_status
  set +e
  create_output=$(python3 -m venv "$target" 2>&1)
  create_status=$?
  set -e
  if (( create_status != 0 )); then
    echo "${RED}failed to create venv${RST}: '$target'" >&2
    [[ -n "$create_output" ]] && echo "$create_output" >&2
    if [[ "$create_output" == *"No module named"* ]]; then
      __indent "hint: your python3 installation is missing the 'venv' module" >&2
    fi
    exit "$create_status"
  fi
}

_venv_remove() {
  local do_remove=0
  local name="$DEFAULT_VENV"
  for arg in "$@"; do
    [[ $arg == -f ]] && do_remove=1 && continue
    [[ $arg =~ ^(rm|remove)$ ]] && continue
    name=$arg
  done
  if [[ ! -d $name ]]; then
    echo "${RED}venv not found${RST}: '${name}'" >&2
    exit 1
  fi
  local answer;
  while (( do_remove == 0 )); do
    printf "%s" "${CYN}>> do you want to remove '${name}'?${RST} (y/N) "
    read -r answer
    if [[ "$answer" =~ ^[yY] ]]; then
      do_remove=1
    elif [[ "$answer" =~ ^[nN] ]]; then
      echo "${RED}okay, aborting now${RST}"
      exit 0
    fi
  done
  if (( do_remove == 1 )); then
    if rm -rf "$name"; then
      echo "${GRN}deleted venv${RST}: '${name}'"
    else
      echo "${RED}failed to delete venv${RST}: '${name}'" >&2
      echo "do you have sufficient permissions?" >&2
      exit 1
    fi
  fi
}

_venv_shellenv() {
  local shell
  shell=$(__detect_shell)

  case "$shell" in
    zsh)
      cat << 'HEREDOC'
# ---- venv zsh functions ----
_venv_activate() {
  local target="${1:-.venv}"
  if [ -f "$target/bin/activate" ]; then
    . "$target/bin/activate"
  else
    echo "venv not found: '$target'"
  fi
}
_venv_deactivate() {
  if command -v deactivate >/dev/null 2>&1; then
    deactivate
  else
    echo "no active venv to deactivate"
  fi
}
venv() {
  case "$1" in
    a|activate) shift; _venv_activate "$@" ;;
    d|deactivate) _venv_deactivate ;;
    v|version|-v|--version) command venv-cli --wrapped version ;;
    *) command venv-cli --wrapped "$@" ;;
  esac
}

# ---- venv zsh completion ----
if whence -w compdef >/dev/null 2>&1; then
  _venv() {
    local line state
    _arguments -C \
      "1: :->cmds" \
      "*::arg:->args"
    case "$state" in
      cmds)
        _values "venv command" \
          "help[shows this help]" \
          "version[shows version]" \
          "init[creates new venv]" \
          "activate[activates venv]" \
          "deactivate[deactivates venv]" \
          "remove[removes venv]" \
          "doctor[performs health check]" \
          "shellenv[echoes shell setup]"
        ;;
      args)
        case $line[1] in
          init)
            _arguments \
              '1:directory:_files -/'
            ;;
          activate)
            _arguments \
              '1:directory:_files -/'
            ;;
          remove)
            _arguments \
              '-f[force removal without confirmation]' \
              '1:directory:_files -/'
            ;;
          *)
            # no additional arguments for other commands
            ;;
        esac
        ;;
    esac
  }
  compdef _venv venv
fi
HEREDOC
      ;;
    fish)
      cat << 'HEREDOC'
# ---- venv fish functions ----
function _venv_activate
  set -l target $argv[1]
  if test -z "$target"
    set target ".venv"
  end
  if test -f "$target/bin/activate.fish"
    source "$target/bin/activate.fish"
  else
    echo "venv not found: '$target'"
  end
end
function _venv_deactivate
  if functions -q deactivate
    deactivate
  else
    echo "no active venv to deactivate"
  end
end
function venv
  switch $argv[1]
    case a activate
      _venv_activate $argv[2..-1]
    case d deactivate
      _venv_deactivate
    case v version -v --version
      command venv-cli --wrapped version
    case '*'
      command venv-cli --wrapped $argv
  end
end

# ---- venv fish completion ----
function __venv_complete_commands
  echo help\tshows\ help
  echo version\tshows\ version
  echo init\tcreates\ new\ venv
  echo activate\tactivates\ venv
  echo deactivate\tdeactivates\ venv
  echo remove\tremoves\ venv
  echo doctor\tperforms\ health check
  echo shellenv\techoes\ shell setup
end
complete -c venv -f
complete -c venv -n "__fish_use_subcommand" -a "(__venv_complete_commands)"
complete -c venv -n "__fish_seen_subcommand_from init activate" -a "(__fish_complete_directories)"
complete -c venv -n "__fish_seen_subcommand_from remove" -a "(__fish_complete_directories)" -s f -d "force removal without confirmation"
HEREDOC
      ;;
    *)
      # default to bash
      cat << 'HEREDOC'
# ---- venv bash functions ----
_venv_activate() {
  local target="${1:-.venv}"
  if [ -f "$target/bin/activate" ]; then
    . "$target/bin/activate"
  else
    echo "venv not found: '$target'"
  fi
}
_venv_deactivate() {
  if command -v deactivate >/dev/null 2>&1; then
    deactivate
  else
    echo "no active venv to deactivate"
  fi
}
venv() {
  case "$1" in
    a|activate) shift; _venv_activate "$@" ;;
    d|deactivate) _venv_deactivate ;;
    v|version|-v|--version) command venv-cli --wrapped version ;;
    *) command venv-cli --wrapped "$@" ;;
  esac
}

# ---- venv bash completion ----
_venv_completion() {
  local cur prev
  COMPREPLY=()
  cur="${COMP_WORDS[COMP_CWORD]}"
  prev="${COMP_WORDS[COMP_CWORD-1]}"

  local commands="help version init activate deactivate remove doctor shellenv"

  if (( COMP_CWORD == 1 )); then
    COMPREPLY=( $(compgen -W "$commands" -- "$cur") )
    return 0
  fi

  case "${COMP_WORDS[1]}" in
    init|activate)
      COMPREPLY=( $(compgen -d -- "$cur") )
      ;;
    remove)
      if [[ "$cur" == -* ]]; then
        COMPREPLY=( $(compgen -W "-f" -- "$cur") )
      else
        COMPREPLY=( $(compgen -d -- "$cur") )
      fi
      ;;
    *)
      COMPREPLY=()
      ;;
  esac
}
complete -F _venv_completion venv
HEREDOC
      ;;
  esac
}

_venv_doctor() {
  (
    local passed=0
    local total=0
    local rc_path
    printf "%s\n\n" "checking venv installation... üîç"

    # check 1: get rc file path
    rc_path=$(__rc_file)
    (( total++ ))
    if [[ -f "$rc_path" ]]; then
      echo "${GRN}${total}. found shell rc file${RST}: $rc_path"
      (( passed++ ))
    else
      echo "${YLW}${total}. shell not supported or missing rc file${RST}: '$rc_path'"
      hint="if your shell ('$(__detect_shell)') is supported, create its rc file with \n"
      hint+="'touch $rc_path'"
      __indent "$hint"
    fi

    # check 2: rc file contains eval venv-cli shellenv
    (( total++ ))
    local eval_lines=()
    while IFS= read -r line; do
      eval_lines+=("$line")
    done < <(grep -E 'eval\s+"[^"]*venv-cli\s+shellenv[^"]*"' "$rc_path" 2>/dev/null)
    n_eval_lines=${#eval_lines[@]}
    if [[ $n_eval_lines -eq 0 ]]; then
      echo "${YLW}${total}. venv-cli shellenv may not be evaluated${RST}"
      rc_base="${rc_path##*/}"  # basename of rc file
      hint="add this line to your $rc_base: \n"
      hint+="${BLD}eval \"\$(venv-cli shellenv)\"${RST}"
      __indent "$hint"
    else
      eval_line="${eval_lines[$n_eval_lines-1]}"
      echo "${GRN}${total}. found eval line${RST}: $eval_line"
      (( passed++ ))
      if [[ $n_eval_lines -gt 1 ]]; then
        __indent "${YLW}found $n_eval_lines eval commands, using last${RST}"
      fi
    fi

    # check 3: try to run shellenv command and validate its output
    (( total++ ))
    set +e
    shellenv_stdout=$(venv-cli shellenv 2>/dev/null)
    shellenv_exit=$?
    if [[ $shellenv_exit -eq 0 ]]; then
      (eval "$shellenv_stdout" >/dev/null 2>&1)
      eval_exit=$?
      if [[ $eval_exit -eq 0 ]]; then
        echo "${GRN}${total}. shellenv works and produces valid shell code${RST}"
        (( passed++ ))
      else
        echo "${YLW}${total}. shellenv works but produces invalid shell code${RST}"
        __indent "command succeeded but evaluation failed"
      fi
    else
      echo "${RED}${total}. shellenv command failed${RST}"
      __indent "check that ${BLD}venv-cli${RST} is on your PATH"
    fi
    set -e

    # checks 4-5: functions
    (( total++ ))
    if command -v _venv_activate >/dev/null 2>&1; then
      echo "${GRN}${total}. activate function is defined${RST}"
      (( passed++ ))
    else
      echo "${RED}${total}. activate function is missing${RST}"
    fi

    (( total++ ))
    if command -v _venv_deactivate >/dev/null 2>&1; then
      echo "${GRN}${total}. deactivate function is defined${RST}"
      (( passed++ ))
    else
      echo "${RED}${total}. deactivate function is missing${RST}"
    fi

    # summary
    if (( passed == total )); then
      printf "\n%s\n" "${GRN}health check passed!${RST} üöÄ ($passed/$total)"
    else
      printf "\n%s\n" "${RED}health check failed!${RST} üò± ($passed/$total)"
      hint="venv may not be installed correctly; please check that:\n"
      hint+=" 1. venv-cli is on your PATH somewhere\n"
      hint+=" 2. your shell's rc file contains: ${BLD}eval \"\$(venv-cli shellenv)\"${RST}"
      __indent "$hint"
      return 1
    fi
  )
}

# dispatcher
direct_call=1
cmd=${1:-help}; shift || true
if [[ $cmd == "--wrapped" ]]; then
  direct_call=0
  cmd=${1:-help}; shift || true
fi
case $cmd in
  i|init)         _venv_init "$@" ;;
  rm|remove)      _venv_remove "$@" ;;
  doctor)         _venv_doctor ;;
  shellenv)       _venv_shellenv ;;
  a|activate)     echo "${RED}invalid usage${RST}: please use ${BLD}venv $cmd${RST}" >&2; exit 1 ;;
  d|deactivate)   echo "${RED}invalid usage${RST}: please use ${BLD}venv $cmd${RST}" >&2; exit 1 ;;
  h|help|-h|--help) _venv_usage $direct_call ;;
  v|version|-v|--version) echo "$CLI_VERSION" ;;
  *) echo "${RED}unknown command${RST}: $cmd" >&2; _venv_usage $direct_call >&2; exit 1 ;;
esac
